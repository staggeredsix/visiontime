<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DGX Multi-Camera CV Demo</title>
  <style>
    body { font-family: Arial, sans-serif; background: #0b132b; color: #f5f5f5; margin: 0; padding: 20px; }
    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(360px, 1fr)); gap: 12px; }
    .panel { background: #1c2541; border-radius: 8px; padding: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.4); }
    img { width: 100%; border-radius: 6px; }
    #embeddings { width: 100%; height: 320px; background: #0f172a; border-radius: 8px; }
    .metrics { display: flex; justify-content: space-between; font-size: 12px; }
    .toggles label { margin-right: 12px; }
    form { background: #1c2541; border-radius: 8px; padding: 12px; margin-bottom: 16px; box-shadow: 0 2px 6px rgba(0,0,0,0.4); }
    fieldset { border: 1px solid #3a4b6b; border-radius: 6px; margin-bottom: 12px; }
    legend { padding: 0 6px; font-weight: bold; }
    label { display: block; margin: 8px 0 4px; font-size: 14px; }
    input { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #3a4b6b; background: #0f172a; color: #f5f5f5; }
    button { padding: 10px 16px; border: none; border-radius: 6px; background: #3ddc97; color: #0b132b; font-weight: bold; cursor: pointer; }
    button:disabled { background: #59708f; cursor: not-allowed; }
    .status { margin-top: 8px; font-size: 14px; }
  </style>
</head>
<body>
  <h1>DGX Station GB300 - Multi-Camera CV</h1>
  <div class="toggles">
    <label><input type="checkbox" id="toggle-seg" checked /> Segmentation</label>
    <label><input type="checkbox" id="toggle-depth" checked /> Depth</label>
    <label><input type="checkbox" id="toggle-flow" checked /> Optical Flow</label>
  </div>
  <div id="gpu" class="panel">
    <strong>GPU</strong>
    <div id="gpu-metrics">Waiting for metrics...</div>
  </div>
  <form id="camera-form">
    <fieldset>
      <legend>Camera inputs (up to 4)</legend>
      <div id="camera-inputs"></div>
    </fieldset>
    <button type="submit">Apply cameras</button>
    <div class="status" id="camera-status"></div>
  </form>

  <div class="grid" id="camera-grid"></div>
  <div class="panel">
    <strong>Embedding t-SNE</strong>
    <canvas id="embeddings"></canvas>
  </div>
<script>
  const cameraForm = document.getElementById('camera-form');
  const cameraInputs = document.getElementById('camera-inputs');
  const statusEl = document.getElementById('camera-status');
  const cameraGrid = document.getElementById('camera-grid');
  const gpuMetrics = document.getElementById('gpu-metrics');
  const embedsCanvas = document.getElementById('embeddings');
  const ctx = embedsCanvas.getContext('2d');
  const cams = new Map();
  const maxCameras = 4;
  let ws;
  let localStream;
  let localVideo;
  const uploadSockets = new Map();

  function ensureCameraCard(name) {
    if (cams.has(name)) return cams.get(name);
    const card = document.createElement('div');
    card.className = 'panel';
    card.innerHTML = `<h3>${name}</h3><img id="img-${name}"/><div class="metrics" id="metrics-${name}"></div>`;
    cameraGrid.appendChild(card);
    cams.set(name, card);
    return card;
  }

  function drawEmbeddings(points, labels) {
    ctx.clearRect(0, 0, embedsCanvas.width, embedsCanvas.height);
    const xs = points.map(p => p[0]);
    const ys = points.map(p => p[1]);
    const minX = Math.min(...xs), maxX = Math.max(...xs);
    const minY = Math.min(...ys), maxY = Math.max(...ys);
    points.forEach((p, idx) => {
      const x = ((p[0] - minX) / (maxX - minX + 1e-5)) * embedsCanvas.width;
      const y = ((p[1] - minY) / (maxY - minY + 1e-5)) * embedsCanvas.height;
      ctx.fillStyle = '#3ddc97';
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.fillText(labels[idx] || '', x + 6, y);
    });
  }

  function connectWs() {
    if (ws) {
      ws.close();
    }
    const proto = location.protocol === 'https:' ? 'wss' : 'ws';
    ws = new WebSocket(`${proto}://${location.host}/ws`);
    ws.onmessage = (event) => {
      const payload = JSON.parse(event.data);
      if (payload.type === 'frame') {
        const card = ensureCameraCard(payload.camera);
        const img = card.querySelector(`#img-${payload.camera}`);
        img.src = `data:image/jpeg;base64,${payload.frame}`;
        const m = payload.metrics;
        card.querySelector(`#metrics-${payload.camera}`).textContent = `FPS ${m.fps.toFixed(1)} | Triton ${m.triton_latency_ms.toFixed(1)} ms | End-to-end ${m.end_to_end_ms.toFixed(1)} ms`;
        gpuMetrics.textContent = `GPU Util ${m.gpu_util.toFixed(1)}% | VRAM ${m.vram_used_gb.toFixed(1)} / ${m.vram_total_gb.toFixed(1)} GB`;
      }
      if (payload.type === 'embeddings' && payload.embeddings.points) {
        drawEmbeddings(payload.embeddings.points, payload.embeddings.labels);
      }
    };
    ws.onerror = (err) => console.error('WebSocket error', err);
  }

  async function ensureLocalCamera() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      throw new Error('Web camera access is not supported in this browser');
    }
    if (!localStream) {
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
    }
    if (!localVideo) {
      localVideo = document.createElement('video');
      localVideo.srcObject = localStream;
      await localVideo.play();
    }
    return localVideo;
  }

  async function requestBrowserCameraPermission() {
    statusEl.textContent = 'Requesting permission to use this device\'s webcam...';
    try {
      await ensureLocalCamera();
      statusEl.textContent = 'Webcam ready for streaming.';
      return true;
    } catch (err) {
      console.error('Could not request webcam access', err);
      statusEl.textContent = 'Could not access the local webcam. Check browser permissions and reload.';
      return false;
    }
  }

  function stopBrowserUpload(name) {
    const entry = uploadSockets.get(name);
    if (!entry) return;
    entry.stop = true;
    entry.ws.close();
    uploadSockets.delete(name);
  }

  function stopUnusedUploads(activeNames) {
    [...uploadSockets.keys()].forEach((key) => {
      if (!activeNames.includes(key)) {
        stopBrowserUpload(key);
      }
    });
  }

  async function startBrowserUpload(name, fps = 15) {
    stopBrowserUpload(name);
    const proto = location.protocol === 'https:' ? 'wss' : 'ws';
    const wsUpload = new WebSocket(`${proto}://${location.host}/ws/upload/${encodeURIComponent(name)}`);
    wsUpload.binaryType = 'arraybuffer';
    const state = { ws: wsUpload, stop: false };
    uploadSockets.set(name, state);
    wsUpload.onopen = async () => {
      try {
        const video = await ensureLocalCamera();
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth || 1280;
        canvas.height = video.videoHeight || 720;
        const cctx = canvas.getContext('2d');
        const interval = 1000 / Math.max(fps, 1);
        const sendFrame = async () => {
          if (state.stop || wsUpload.readyState !== WebSocket.OPEN) return;
          cctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          const blob = await new Promise((resolve) => canvas.toBlob(resolve, 'image/jpeg', 0.7));
          if (blob) {
            const buffer = await blob.arrayBuffer();
            wsUpload.send(buffer);
          }
          setTimeout(sendFrame, interval);
        };
        sendFrame();
      } catch (err) {
        console.error('Failed to stream browser camera', err);
        statusEl.textContent = 'Could not access local webcam. Check browser permissions.';
      }
    };
    wsUpload.onclose = () => {
      uploadSockets.delete(name);
    };
  }

  function createCameraRow(idx, data = {}) {
    const wrapper = document.createElement('div');
    const isBrowser = (data.url || '').toLowerCase() === 'browser';
    wrapper.innerHTML = `
      <label for="cam-name-${idx}">Camera ${idx + 1} name</label>
      <input id="cam-name-${idx}" name="cam-name-${idx}" placeholder="cam${idx + 1}" value="${data.name || ''}">
      <label for="cam-url-${idx}">Camera ${idx + 1} URL</label>
      <input id="cam-url-${idx}" name="cam-url-${idx}" placeholder="rtsp://..." value="${data.url || ''}" ${isBrowser ? 'disabled' : ''}>
      <label><input type="checkbox" id="cam-browser-${idx}" ${isBrowser ? 'checked' : ''}> Use this device's webcam</label>
    `;
    const browserToggle = wrapper.querySelector(`#cam-browser-${idx}`);
    const urlInput = wrapper.querySelector(`#cam-url-${idx}`);
    browserToggle.addEventListener('change', () => {
      if (browserToggle.checked) {
        urlInput.value = 'browser';
        urlInput.disabled = true;
        requestBrowserCameraPermission();
      } else {
        urlInput.disabled = false;
        if (urlInput.value === 'browser') urlInput.value = '';
      }
    });
    if (isBrowser) {
      requestBrowserCameraPermission();
    }
    return wrapper;
  }

  async function loadCameras() {
    try {
      const resp = await fetch('/api/cameras');
      const body = await resp.json();
      const camsList = body.cameras || [];
      cameraInputs.innerHTML = '';
      for (let i = 0; i < maxCameras; i++) {
        cameraInputs.appendChild(createCameraRow(i, camsList[i] || {}));
      }
      return camsList;
    } catch (err) {
      console.error('Failed to load cameras', err);
      return [];
    }
  }

  async function submitCameras(event) {
    event.preventDefault();
    statusEl.textContent = 'Updating camera list...';
    const payload = { cameras: [] };
    for (let i = 0; i < maxCameras; i++) {
      const name = document.getElementById(`cam-name-${i}`).value.trim();
      const url = document.getElementById(`cam-url-${i}`).value.trim();
      const browserChecked = document.getElementById(`cam-browser-${i}`)?.checked;
      if (!name && !url) continue;
      if (!name || !url) {
        statusEl.textContent = 'Each camera needs both name and URL.';
        return;
      }
      payload.cameras.push({ name, url: browserChecked ? 'browser' : url });
    }
    if (payload.cameras.length === 0) {
      statusEl.textContent = 'Provide at least one camera.';
      return;
    }
    if (payload.cameras.length > maxCameras) {
      statusEl.textContent = 'Maximum of four cameras supported.';
      return;
    }
    try {
      const resp = await fetch('/api/cameras', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!resp.ok) {
        const msg = await resp.text();
        statusEl.textContent = `Failed: ${msg}`;
        return;
      }
      statusEl.textContent = 'Updated cameras. Streams will refresh shortly.';
      cams.clear();
      cameraGrid.innerHTML = '';
      connectWs();
      const browserCams = payload.cameras.filter((c) => c.url.toLowerCase() === 'browser').map((c) => c.name);
      stopUnusedUploads(browserCams);
      browserCams.forEach((name) => startBrowserUpload(name));
    } catch (err) {
      console.error(err);
      statusEl.textContent = 'Error updating cameras.';
    }
  }

  cameraForm.addEventListener('submit', submitCameras);
  loadCameras().then((camsList) => {
    const browserCams = camsList.filter((c) => (c.url || '').toLowerCase() === 'browser').map((c) => c.name);
    if (browserCams.length) {
      browserCams.forEach((name) => startBrowserUpload(name));
    }
    connectWs();
  });
</script>
</body>
</html>
